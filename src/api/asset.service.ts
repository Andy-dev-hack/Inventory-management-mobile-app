import { AssetSchema, type Asset } from "../schemas/asset.schema";
import { handleAsync, type AsyncResult } from "../utils/handle-async";
import { supabase } from "../lib/supabase";

const normalizeDate = (date: string | null | undefined): string | undefined => {
  if (!date) return undefined;
  try {
    return new Date(date).toISOString();
  } catch {
    /* v8 ignore next */
    return date; // Let Zod handle the validation error if invalid
  }
};

// Helper: Map DB (snake_case) -> App (camelCase)
interface AssetRow {
  serial_number?: string | null;
  purchase_date?: string | null;
  created_at?: string | null;
  user_id?: string | null;
  [key: string]: unknown;
}

const mapToAsset = (row: AssetRow): unknown => ({
  ...row,
  serialNumber: row.serial_number,
  purchaseDate: normalizeDate(row.purchase_date),
  createdAt: normalizeDate(row.created_at),
  userId: row.user_id,
});

// Helper: Map App (camelCase) -> DB (snake_case)
const mapToDb = (input: Partial<Asset>) => {
  return {
    name: input.name,
    category: input.category,
    value: input.value,
    status: input.status,
    // Optional fields
    serial_number: input.serialNumber ?? null,
    purchase_date: input.purchaseDate, // Supabase handles timestamptz fine
    // ID is auto-generated by DB if missing
    // created_at is auto-generated
  };
};

export const AssetService = {
  getAssets: async (): AsyncResult<Asset[]> => {
    const fetchAction = (async (): Promise<Asset[]> => {
      // 1. Fetch from Supabase
      const { data, error } = await supabase
        .from("assets")
        .select("*")
        .order("created_at", { ascending: false });

      if (error) throw new Error(error.message);

      // 2. Transform & Validate (Defensive Programming)
      const validAssets: Asset[] = [];

      /* v8 ignore next */
      for (const row of data || []) {
        const camel = mapToAsset(row);
        const result = AssetSchema.safeParse(camel);

        if (result.success) {
          validAssets.push(result.data);
        } else {
          console.warn("Skipping corrupted asset:", row, result.error);
        }
      }

      return validAssets;
    })();

    return handleAsync(fetchAction);
  },

  saveAsset: async (input: unknown): AsyncResult<Asset> => {
    const saveAction = (async (): Promise<Asset> => {
      // 1. Schema Validation (Client Side)
      const result = AssetSchema.safeParse(input);
      if (!result.success) {
        throw new Error(`Validation failed: ${result.error.message}`);
      }
      const assetData = result.data;

      // 2. Map to DB format
      const dbPayload = mapToDb(assetData);

      // 3. Send to Supabase
      const { data, error } = await supabase
        .from("assets")
        .insert(dbPayload)
        .select()
        .single();

      if (error) throw new Error(error.message);

      // 4. Map back to verified Asset
      const savedAsset = mapToAsset(data);
      return AssetSchema.parse(savedAsset); // Strict re-validation
    })();

    return handleAsync(saveAction);
  },

  updateAsset: async (
    id: string,
    updates: Partial<Asset>,
  ): AsyncResult<Asset> => {
    const updateAction = (async (): Promise<Asset> => {
      // 1. Map updates to snake_case
      // Note: We create a partial DB object manually to avoid wiping missing fields
      const dbUpdates: Record<string, unknown> = {};
      if (updates.name) dbUpdates.name = updates.name;
      if (updates.category) dbUpdates.category = updates.category;
      if (updates.value) dbUpdates.value = updates.value;
      if (updates.status) dbUpdates.status = updates.status;
      if (updates.serialNumber !== undefined)
        dbUpdates.serial_number = updates.serialNumber;
      if (updates.purchaseDate) dbUpdates.purchase_date = updates.purchaseDate;

      // 2. Update in Supabase
      const { data, error } = await supabase
        .from("assets")
        .update(dbUpdates)
        .eq("id", id)
        .select()
        .single();

      if (error) throw new Error(error.message);

      // 3. Map back and Return
      const updatedAsset = mapToAsset(data);
      return AssetSchema.parse(updatedAsset);
    })();

    return handleAsync(updateAction);
  },

  deleteAsset: async (id: string): AsyncResult<boolean> => {
    const deleteAction = (async (): Promise<boolean> => {
      const { error } = await supabase.from("assets").delete().eq("id", id);

      if (error) throw new Error(error.message);
      return true;
    })();

    return handleAsync(deleteAction);
  },
};
